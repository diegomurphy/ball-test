<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Mobile Tilt Physics + Sound + Drag</title>

  <script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #f5f5f5;
      touch-action: none;
    }
    canvas { display: block; }
    #enable-motion {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 20px;
      font-size: 16px;
      background: #222;
      color: #fff;
      border: none;
      border-radius: 10px;
      z-index: 10;
      cursor: pointer;
    }
  </style>
</head>

<body>
<button id="enable-motion">Enable Motion</button>

<script>
/* ---------------------------------------------------------
   MATTER.JS ENGINE SETUP
--------------------------------------------------------- */
const { Engine, Render, Runner, World, Bodies, Body, Events, Vector } = Matter;

const engine = Engine.create();
engine.world.gravity.scale = 0.0015;

const render = Render.create({
  element: document.body,
  engine: engine,
  options: {
    width: innerWidth,
    height: innerHeight,
    wireframes: false,
    background: '#f5f5f5'
  }
});
Render.run(render);
Runner.run(Runner.create(), engine);

/* ---------------------------------------------------------
   WALLS
--------------------------------------------------------- */
function createWalls() {
  const w = innerWidth;
  const h = innerHeight;
  const t = 100;
  return [
    Bodies.rectangle(w/2, -t/2, w, t, { isStatic: true }),
    Bodies.rectangle(w/2, h+t/2, w, t, { isStatic: true }),
    Bodies.rectangle(-t/2, h/2, t, h, { isStatic: true }),
    Bodies.rectangle(w+t/2, h/2, t, h, { isStatic: true })
  ];
}
let walls = createWalls();
World.add(engine.world, walls);

/* ---------------------------------------------------------
   BALLS
--------------------------------------------------------- */
const balls = [];
for (let i = 0; i < 10; i++) {
  const ball = Bodies.circle(
    50 + (i * 35),
    80 + ((i % 3) * 30),
    20,
    {
      restitution: 0.7,
      friction: 0.01,
      render: { fillStyle: '#3498db' }
    }
  );
  balls.push(ball);
  World.add(engine.world, ball);
}

/* ---------------------------------------------------------
   WOOD-KNOCK COLLISION SOUND (embedded base64 WAV)
--------------------------------------------------------- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const knockBase64 =
"UklGRlgAAABXQVZFZm10IBAAAAABAAEAgD4AAAB9AAACABAAZGF0YVgAAAAA/////wAAAP///wAAAP8A" +
"AAAA/wAAAP///wD///8AAP///wAAAP8A/////wAA////AP///wAA////AAAA/wD///8AAP8A////AAAA";

let knockBuffer = null;

fetch("data:audio/wav;base64," + knockBase64)
  .then(r => r.arrayBuffer())
  .then(arr => audioCtx.decodeAudioData(arr))
  .then(buf => { knockBuffer = buf; });

function playKnock(volume = 0.3) {
  if (!knockBuffer) return;
  const src = audioCtx.createBufferSource();
  const gain = audioCtx.createGain();
  gain.gain.value = volume;
  src.buffer = knockBuffer;
  src.connect(gain).connect(audioCtx.destination);
  src.start(0);
}

/* ---------------------------------------------------------
   PLAY SOUND ON COLLISION
--------------------------------------------------------- */
Events.on(engine, "collisionStart", (event) => {
  event.pairs.forEach(pair => {
    const v = pair.collision.depth + pair.collision.penetration;
    const intensity = Math.min(Math.abs(v) * 2, 1);
    if (intensity > 0.05) playKnock(intensity);
  });
});

/* ---------------------------------------------------------
   TOUCH-DRAG + FLICK
--------------------------------------------------------- */
let activeBall = null;
let lastPos = null;

function getTouchPos(e) {
  const t = e.touches[0];
  return { x: t.clientX, y: t.clientY };
}

function findBallAt(x, y) {
  return balls.find(b => {
    const dx = b.position.x - x;
    const dy = b.position.y - y;
    return Math.sqrt(dx*dx + dy*dy) < 25;
  });
}

window.addEventListener("touchstart", e => {
  const p = getTouchPos(e);
  const hit = findBallAt(p.x, p.y);
  if (hit) {
    activeBall = hit;
    Body.setStatic(activeBall, true);
    lastPos = p;
  }
}, { passive: false });

window.addEventListener("touchmove", e => {
  if (!activeBall) return;
  const p = getTouchPos(e);
  Body.setPosition(activeBall, p);
  lastPos = p;
}, { passive: false });

window.addEventListener("touchend", e => {
  if (!activeBall || !lastPos) return;

  const end = lastPos;
  const start = activeBall.position;
  const velocity = {
    x: (end.x - start.x) * 0.2,
    y: (end.y - start.y) * 0.2
  };

  Body.setStatic(activeBall, false);
  Body.setVelocity(activeBall, velocity);

  activeBall = null;
  lastPos = null;
});

/* ---------------------------------------------------------
   TILT-TO-GRAVITY
--------------------------------------------------------- */
function handleOrientation(e) {
  if (e.beta == null || e.gamma == null) return;
  engine.world.gravity.x = Math.max(-1, Math.min(1, e.gamma / 45));
  engine.world.gravity.y = Math.max(-1, Math.min(1, e.beta / 45));
}
addEventListener("deviceorientation", handleOrientation, true);

/* ---------------------------------------------------------
   iOS MOTION PERMISSION
--------------------------------------------------------- */
const btn = document.getElementById("enable-motion");
btn.addEventListener("click", async () => {
  if (typeof DeviceMotionEvent !== "undefined" &&
      typeof DeviceMotionEvent.requestPermission === "function") {
    try {
      const res = await DeviceMotionEvent.requestPermission();
      if (res !== "granted") {
        alert("Motion access denied");
        return;
      }
    } catch (e) { console.error(e); }
  }
  btn.remove();
});

/* ---------------------------------------------------------
   RESIZE HANDLING
--------------------------------------------------------- */
addEventListener("resize", () => {
  Render.stop(render);
  World.remove(engine.world, walls);
  walls = createWalls();
  World.add(engine.world, walls);
  render.canvas.width = innerWidth;
  render.canvas.height = innerHeight;
  Render.run(render);
});
</script>
</body>
</html>
